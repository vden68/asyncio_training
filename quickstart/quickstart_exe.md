(1) blocking() обычно вызывает внутри себяtime.sleep(), что привело бы к блокировке вашего основного потока и предотвращало бы исполнение вашего цикла событий. Это означает, что вам не следует делать такую функцию сопрограммой, но что ещё более серьёзно, вы не можете вызывать эту функцию из любого места в своём основном потоке, который является именно тем местом, в котором исполняется основной цикл asyncio. Мы решаем данную проблему запуская эту функцию в некотором исполнителе (executor).

(2) Безотносительно к данному разделу, но нечто, что следует держать на уме далее в этой книге: отметим, что значение времени сна с блокировкой (0.5 секунды) короче чем значение засыпания без блокировки (1 секунда) в вашей сопрограмме main(). Это делает данный код примера изящным и опрятным. В своём следующем разделе мы объясним что бы произошло если бы функции исполнителя переживали бы свои асинхронные эквиваленты во время последовательности выключения.

(3) await loop.run_in_executor(None, func)

Это самый последний момент в нашем списке существенных функций asyncio, о которых следует знать. Иногда вам требуется запускать вещи в некотором отдельном потоке, или даже в отдельном процессе: данный метод применяется именно для этого. Здесь мы передаём свою блокирующую функцию для запуска в определённом по умолчанию исполнителе. [к сожалению, самым первым параметром run_in_executor() является сам экземпляр Executor, который следует применять и вы обязаны передать None чтобы использовать установленный по умолчанию. Всякий раз, как я применяю это, я ощущаю как мой параметр "исполнитель" плачет, будучи вынужденным именоваться ключевым словом аргумента с определённым по умолчанию значением None.]

Отметим, что loop.run_in_executor() возвращает некое Future, что означает, что вы можете await {подождать} его при вызове в рамках функции другой сопрограммы.

(4) Продолжаем отмечать вслед за элементом 2: наш набор задач в pending не содержит некоего элемента для того вызова blocking(), который делается в run_in_executor(). Это будет справедливо для любого вызова, который возвращает некое Future вместо какой- то Task. Имеющаяся документация достаточно хорошо определяет возвращаемые типы, поэтому об этом несложно знать; всего лишь просто запомните, что all_tasks() на самом деле возвращает только Task, и никаких Future.

Теперь, когда вы ознакомились с наиболее существенными частями asyncio для потребностей разработки конечных приложений, наступило время объяснять нашу сферу и выстроить перечисленные API asyncio в некий вид иерархии. Это облегчит усвоение и понимание того как получать то что вам требуется из имеющейся документации, но не более того.